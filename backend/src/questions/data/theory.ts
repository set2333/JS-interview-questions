import { AvailableQuestionTypes, Question } from "../../types";

export const theoryQuestions: Omit<Question, 'id'>[] = [
  {
    question: 'Альтернативы web-sockets',
    answer: `<b>Polling</b> - запросы отправляются через небольшой интервал времени, например 10 секунд. 
    Сервер отмечает, что клиент онлайн. И возвращает ему все накопившиеся данные за предидущий интервал. Минусы в постоянной атаке сервера запросами и в задержке при получении данных.</br>
     <b>Long polling</b> - отправка запроса, который не завершиться пока не будет ответа. То есть сервер ждет, пока появятся новые данные и сразу возвращает их. 
     Клиент, как только получает ответ, отправляет новый запрос. При этом сервер должен уметь работать сочень большим количеством соединений. 
     В случае если сервер выделяет отдельный поток для каждого соединения, у него может закончиться память.</br>
     <b>Event sourcing</b> - соединение остается открытым все время. 
     При его создании указываються заголовки <i>'Connection': 'keep-alive'</i>, <i>''Content-Type': 'text/event-stream'</i>, <i>'Cache-Control': 'no-cache'</i>.
     Когда на сервере появляются данные для отправки он отправляет их в виде строки: <i>data: \${JSON.stringify(data)} \\n\\n</i></br>
     Соединение остается открытым, что так же может нагрузить память сервера.`,
  },
  {
    question: 'SOLID',
    answer: `<b>S – Single Responsibility (Принцип единственной ответственности)</b> - Каждый класс должен отвечать только за одну операцию.</br>
    <b>O — Open-Closed (Принцип открытости-закрытости)</b> - Классы должны быть открыты для расширения, но закрыты для модификации.</br>
    <b>L — Liskov Substitution (Принцип подстановки Барбары Лисков)</b> - Если подставить вместо родителя потомка, не должно возникнуть негативных эффектов.</br>
    <b>I — Interface Segregation (Принцип разделения интерфейсов)</b> - Не следует ставить клиент в зависимость от методов, которые он не использует.</br>
    <b>D — Dependency Inversion (Принцип инверсии зависимостей)</b> - Модули верхнего уровня не должны зависеть от модулей нижнего уровня. 
    И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</br>
    `,
  },
  {
    question: 'ООП',
    answer: `<b>Инкапсуляция</b> - сокрытие внутренних данных компонента и деталей его реализации от других компонентов приложения.</br>
    <b>Наследование</b> - использование потомком свойств и методов своего родителя.</br>
    <b>Полиморфизм</b> - использование объектов с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</br>
    <b>Абстракция</b> - использование абстрактных методов, без погружения во внутреннюю логику.</br>
    `,
  },
].map(question => ({ ...question, type: AvailableQuestionTypes.THEORY }));

