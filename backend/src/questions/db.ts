import { Question, QuestionType } from "src/types";

export const questions: Omit<Question, 'id'>[] = [
  {
    type: 'html',
    question: 'Работа с формами',
    answer: `Работа с формами происходит через тег <b>form</b>. В него можно обернуть теги <b>input</b> с атрибутами <b>type=(text|password|naumber)</b> и <b>name</b> - имя поля.
    Также добавляеться <b>input</b> с типом <b>submit</b>, который и производит отправку формы.</br>
    Возможно использовать следующие теги: <b>input</b>, <b>select</b>, <b>label</b>, <b>button</b>, <b>textarea</b>.
    Не стоит использовать блочные теги (<b>div</b>).
    <h4>Атрибуты тега форм</h4>
    <ul>
      <li><b>action</b> - адрес отправки формы</li>
      <li><b>method</b> - http метод (GET, POST)</li>
      <li><b>target</b> - окно в котором будет открыт результат отправки данных формы</li>
      <li><b>name</b> - имя формы</li>
      <li><b>autocomplete</b> - может ли браузер запоминать введённые пользователем данные</li>
      <li><b>enctype</b> - способ кодирования данных формы</li>
      <li><b>novalidate</b> - указывает, что данные формы не нужно проверять на корректность</li>
      <li><b>onsubmit</b> - обработчик отправки формы</li>
    </ul>
    В JS можно обратиться у форме например так: <b>document.forms[formName]</b>.</br>
    Далее можно добавить слушатель события <b>addEventListener('submit', handler)</b></br>
    Для отмены отправки формы можно использовать <b>preventDefault()</b>. Обычно это используют для валидации данных формы.
    `,
  },
  {
    type: 'css',
    question: 'В чем отличие em и rem',
    answer: `<b>em</b> - размер относительно родительского размера. Например если у родителя размер шрифта 20px, а у потомка 0.8em, то его размер будет равен 16px.</br>
    <b>rem</b> - расчет размера такойже как и для em, но вместо родителя использеутся размер для тега <b>html</b>`,
  },
  {
    type: 'css',
    question: 'Что такое БЭМ',
    answer: `<b>БЭМ (Блок, Элемент, Модификатор)</b> — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки.</br>
    <b>Блок</b> - Функционально независимый компонент страницы. Представлены атрибутом class. Название отвечает на вопрос <i>Что это? (menu, header, footer)</i></br>
    <b>Элемент</b> -  часть блока, которая не может использоваться в без него. Имя элемента отделяется от имени блока двумя подчеркиваниями (<i>имя-блока__имя-элемента</i>)</br>
    Элемент может быть вложен в другой элемент, но в названии это не отражается. Там он всегда часть блока.</br>
    <b>Модификатор</b> - определяющая внешний вид, состояние или поведение. Имя отделяется одинарным подчеркиванием. Должно отвечать на вопрос <i>Какой</i> (Какой размер, какая тема, какой цвет)</br>
    Модификатор можно использоват только с блоком или элементом, но не самостоятельно.
    `,
  },
  {
    type: 'theory',
    question: 'Альтернативы web-sockets',
    answer: `<b>Polling</b> - запросы отправляются через небольшой интервал времени, например 10 секунд. 
    Сервер отмечает, что клиент онлайн. И возвращает ему все накопившиеся данные за предидущий интервал. Минусы в постоянной атаке сервера запросами и в задержке при полученн данных.</br>
     <b>Long polling</b> - отправка запроса, который не завершиться пока не будет ответа. То есть сервер ждет, пока появятся новые данные и сразу возвращает их. 
     Клиент, как только получает ответ, отправляет новый запрос. При этом сервер должен уметь работать сочень большим количествои соединений. 
     В случае если сервер выделяет отдельный поток для каждого соединения, у него может закончиться память.</br>
     <b>Event sourcing</b> - соединение остаеться открытым все время. 
     При его создании указываються заголовки <i>'Connection': 'keep-alive'</i>, <i>''Content-Type': 'text/event-stream'</i>, <i>'Cache-Control': 'no-cache'</i>.
     Когда на сервере появляються данные для отправки он отправляет их в виде строки: <i>data: \${JSON.stringify(data)} \\n\\n</i></br>
     Соединение остается открытым, что так же может нагрузить панять сервера.`,
  },
  {
    type: 'js',
    question: 'Что такое this?',
    answer: `Это контекст выполнения. В случае если мы работаем с объектом, то <b>this</b> будет указывать на этот объект. 
    В обычном коде <b>this</b> будет ссылаться на глобальный объект (<b>window</b>, или <b>global</b> для nodejs).</br>
    Если мы объявим метод объекта через <b>function</b>, то <b>this</b> в этой функции будет сам объект, 
    но если метод объявлен через стрелочную функцию, то <b>this</b> будет ссылаться на контекст выполнения вызывающего кода.
    Это происходит потому, что у стрелочных функций не контекста.</br>
    Можно вызвать функцию с явным указанием контекста. Для этого существуют методы <b>call(context, ...args)</b> и <b>apply(context, [...args])</b></br>
    Также можно привязать контекст к функции через метод <b>bind(context, ...args)</b>. Не возможно привязать контекст повторно, и не возможно привязать контекст к стрелочной функции.
    `,
  },
  {
    type: 'js',
    question: 'Что такое event loop?',
    answer: `Это цикл событий. Нужен для организации асинхронного кода. Являеться часть среды (браузер, nodejs).</br>
    Сначала выполняеться синхронный код. Затем приходит очередь микро-тасков. 
    Это таски из <b>Promise</b>, <b>queueMicrotask</b> и <b>Intersection Observer</b> (api для отслеживания пересечения блока с другим блоком или областью видимости). 
    Если микро-таски порождают другие микро-таски, то очередь выполнения продолжится, пока они не выполнятся все (ну или приложение ляжет).</br>
    Дальше идет очередь макро-тасков. Туда попадаютт остальные задачи (<b>fetch, eventListenrs, setTimeout</b> и все остальное из browser-api). 
    После выполнения одной макро-задачи, опять проверяеться очередь микро-тасков. Затем получаеться следующий макро-таск. И так происходит бесконечно.
    `,
  },
  {
    type: 'react',
    question: 'Для чего нужен хук useEffect',
    answer: 'Для side эфектов',
  },
];

export const questionTypes: QuestionType[] = [
  { id: 'js', label: 'Вопросы по JS' },
  { id: 'css', label: 'Вопросы по CSS' },
  { id: 'html', label: 'Вопросы по HTML' },
  { id: 'theory', label: 'Общие вопросы' },
  { id: 'react', label: 'Вопросы по React' },
];
